/++
For generating byte code from AST
+/
module qscript.compiler.codegen;

import qscript.compiler.ast;
import qscript.compiler.astcheck;
import qscript.compiler.misc;
import qscript.compiler.compiler : Function;

import utils.misc;
import utils.lists;

import navm.navm : Instruction, NaData;
import navm.bytecodedefs; // needed to check how many elements instruction wants from stack

import std.conv : to;

/// Contains functions to generate ByteCode from AST nodes
class CodeGen{
private:
	/// the generated byte code
	List!string code;
	/// the instructions of the function currently being converted to byte code
	List!(Instruction) instructions;
	/// the arguments for instructions above
	List!(NaData[]) instArgs;
protected:
	/// generates byte code for a FunctionNode
	void generateByteCode(FunctionNode node){

	}
	/// generates byte code for a BlockNode
	void generateByteCode(BlockNode node){
		foreach (statement; node.statements){
			generateByteCode(statement);
		}
	}
	/// generates byte code for a StatementNode
	void generateByteCode(StatementNode node){
		if (node.type == StatementNode.Type.Assignment){
			generateByteCode(node.node!(StatementNode.Type.Assignment));
		}else if (node.type == StatementNode.Type.Block){
			generateByteCode(node.node!(StatementNode.Type.Block));
		}else if (node.type == StatementNode.Type.DoWhile){
			generateByteCode(node.node!(StatementNode.Type.DoWhile));
		}else if (node.type == StatementNode.Type.For){
			generateByteCode(node.node!(StatementNode.Type.For));
		}else if (node.type == StatementNode.Type.FunctionCall){
			generateByteCode(node.node!(StatementNode.Type.FunctionCall));
			// TODO add Pop instruction
		}else if (node.type == StatementNode.Type.If){
			generateByteCode(node.node!(StatementNode.Type.If));
		}else if (node.type == StatementNode.Type.VarDeclare){
			generateByteCode(node.node!(StatementNode.Type.VarDeclare));
		}else if (node.type == StatementNode.Type.While){
			generateByteCode(node.node!(StatementNode.Type.While));
		}else if (node.type == StatementNode.Type.Return){
			generateByteCode(node.node!(StatementNode.Type.Return));
		}
	}
	/// generates byte code for AssignmentNode
	void generateByteCode(AssignmentNode node){

	}
	/// generates ByteCode for DoWhileNode
	void generateByteCode(DoWhileNode node){

	}
	/// generates byte code for ForNode
	void generateByteCode(ForNode node){

	}
	/// generates byte code for FunctionCallNode
	void generateByteCode(FunctionCallNode node){
		if (!node.isScriptDefined && node.isInBuilt){
			generateInBuiltFunctionByteCode(node);
		}else{

		}
	}
	/// generates byte code for inbuilt QScript functions (`length(void[])` and stuff)
	void generateInBuiltFunctionByteCode(FunctionCallNode node){
		/// argument types of function call
		DataType[] argTypes;
		argTypes.length = node.arguments.length;
		foreach (i, arg; node.arguments){
			argTypes[i] = arg.returnType;
		}
		/// encoded name of function
		string fName = encodeFunctionName(node.fName, argTypes);
		/// length(@void[], int)
		if (node.fName == "length"){
			if (matchArguments([DataType(DataType.Type.Void, 1, true), DataType(DataType.Type.Integer)],argTypes)){
				// set array length
			}else if (matchArguments([DataType(DataType.Type.Void, 1)], argTypes)){
				// get array length
			}else if (matchArguments([DataType(DataType.Type.String)], argTypes)){
				/// length(string)
			}
		}else if (fName == encodeFunctionName("toInt", [DataType(DataType.Type.String)])){
			/// toInt(string)
		}else if (fName == encodeFunctionName("toInt", [DataType(DataType.Type.Double)])){
			/// toInt(double)
		}else if (fName == encodeFunctionName("toDouble", [DataType(DataType.Type.String)])){
			/// toDouble(string)
		}else if (fName == encodeFunctionName("toDouble", [DataType(DataType.Type.Integer)])){
			/// toDouble(int)
		}else if (fName == encodeFunctionName("toStr", [DataType(DataType.Type.Integer)])){
			/// toStr(int)
		}else if (fName == encodeFunctionName("toStr", [DataType(DataType.Type.Double)])){
			/// toStr(double)
		}
	}
	/// generates byte code for IfNode
	void generateByteCode(IfNode node){
		
	}
	/// generates byte code for VarDeclareNode - actually, just checks if a value is being assigned to it, if yes, makes var a ref to that val
	void generateByteCode(VarDeclareNode node){

	}
	/// generates byte code for WhileNode
	void generateByteCode(WhileNode node){

	}
	/// generates byte code for ReturnNode
	void generateByteCode(ReturnNode node){

	}

	/// generates byte code for CodeNode
	void generateByteCode(CodeNode node){
		if (node.type == CodeNode.Type.FunctionCall){
			generateByteCode(node.node!(CodeNode.Type.FunctionCall));
		}else if (node.type == CodeNode.Type.Literal){
			generateByteCode(node.node!(CodeNode.Type.Literal));
		}else if (node.type == CodeNode.Type.Operator){
			generateByteCode(node.node!(CodeNode.Type.Operator));
		}else if (node.type == CodeNode.Type.SOperator){
			generateByteCode(node.node!(CodeNode.Type.SOperator));
		}else if (node.type == CodeNode.Type.ReadElement){
			generateByteCode(node.node!(CodeNode.Type.ReadElement));
		}else if (node.type == CodeNode.Type.Variable){
			generateByteCode(node.node!(CodeNode.Type.Variable));
		}else if (node.type == CodeNode.Type.Array){
			generateByteCode(node.node!(CodeNode.Type.Array));
		}
	}
	/// generates byte code for LiteralNode
	void generateByteCode(LiteralNode node){

	}
	/// generates byte code for OperatorNode
	void generateByteCode(OperatorNode node){
		
	}
	/// generates byte code for SOperatorNode
	void generateByteCode(SOperatorNode node){
		// only 2 SOperators exist at this point, ref/de-ref, and `!`
		if (node.operator == "@"){
			// check if its being de-ref-ed
			if (node.operand.returnType.isRef){
				// deref
			}else{
				// get ref
			}
		}else if (node.operator == "!"){

		}
	}
	/// generates byte code for ReadElement
	void generateByteCode(ReadElement node){

		if (node.readFromNode.returnType.arrayDimensionCount > 0){
			// is array
		}else if (node.readFromNode.returnType.type == DataType.Type.String){
			// is string
		}
	}
	/// generates byte code for VariableNode
	void generateByteCode(VariableNode node){
		
	}
	/// generates byte code for ArrayNode
	void generateByteCode(ArrayNode node){

	}
public:
	/// constructor
	/// 
	/// `bCode` is the ByteCode to which the byte code is written
	this (){

	}
	/// destructor
	~this(){

	}
	/// generates byte code for ScriptNode
	void generateByteCode(ScriptNode node){
		foreach (func; node.functions){
			generateByteCode(func);
		}
	}
}

private class NaByteCodeWriter{
private:
	/// code for each function
	List!NaFunction _generatedCode;
	/// instructions of function currently being written to
	List!Instruction _currentInst;
	/// arguments of instructions of functions currently being written to
	List!(NaData[]) _currentInstArgs;
	/// number of elements used up on stack at a point
	uinteger _currentStackUsage;
	/// max number of elements used on on stack (reset to 0 before starting on a new function)
	uinteger _maxStackUsage;

	/// called to update _maxStackUsageg if necessary
	void updateStackUsage(){
		if (_currentStackUsage > _maxStackUsage)
			_maxStackUsage = _currentStackUsage;
	}
public:
	/// Stores types of errors given by `this.addInstruction`
	enum ErrorType : ubyte{
		StackElementsInsufficient, /// the instructions needs to pop more elements than there are, on the stack
		ArgumentCountMismatch, /// instruction needs different number of arguemnts than provided
		NoError, /// there was no error
	}
	/// constructor
	this(){
		_generatedCode = new List!NaFunction;
		_currentInst = new List!Instruction;
		_currentInstArgs = new List!(NaData[]);
	}
	/// destructor
	~this(){
		.destroy(_generatedCode);
		.destroy(_currentInst);
		.destroy(_currentInstArgs);
	}
	/// Returns: generated byte code in a NaFunction[]
	NaFunction[] getCode(){
		return _generatedCode.toArray;
	}
	/// Call to prepare writing a function
	void startFunction(uinteger argCount){
		// clear lists
		_currentInst.clear;
		_currentInstArgs.clear;
		// make space for arguments on stack
		_maxStackUsage = argCount;
		_currentStackUsage = argCount;
	}
	/// Call when a function has been completely written to.
	void appendFunction(){
		NaFunction func;
		func.instructions = _currentInst.toArray;
		func.arguments = _currentInstArgs.toArray;
		func.stackLength = _maxStackUsage;
		_generatedCode.append(func);
		// reset
		_currentInst.clear;
		_currentInstArgs.clear;
		_maxStackUsage = 0;
		_currentStackUsage = 0;
	}
	/// Returns: nunmber of elements currently on stack
	@property uinteger stackLength(){
		return _currentStackUsage;
	}
	/// Returns: number of instructions
	@property uinteger instructionCount(){
		return _currentInst.length;
	}
	/// Adds an instruction
	///
	/// Returns: type of error if any, else, ErrorType.NoError
	ErrorType addInstruction(Instruction inst, NaData[] args){
		if (args.length != INSTRUCTION_ARG_COUNT[inst])
			return ErrorType.ArgumentCountMismatch;
		immutable uinteger popCount = instructionPopCount(inst, args);
		if (popCount > _currentStackUsage)
			return ErrorType.StackElementsInsufficient;
		_currentStackUsage -= popCount;
		updateStackUsage;
		_currentInst.append(inst);
		_currentInstArgs.append(args.dup);
		return ErrorType.NoError;
	}
	/// Changes argument of jump/jumpIf instruction at an index
	/// 
	/// Returns: true if done, false if not, usually because the instruction there isn't a jump/jumpIf
	bool changeJumpArg(uinteger index, uinteger newJumpIndex){
		if (index >= _currentInst.length || ! [Instruction.Jump, Instruction.JumpIf].hasElement(_currentInst.read(index)))
			return false;
		_currentInstArgs.set(index, [NaData(newJumpIndex)]);
		return true;
	}
}