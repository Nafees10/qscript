module qscript.compiler.astcheck;

import qscript.compiler.ast;
import qscript.compiler.misc;

import utils.lists;
import utils.misc;

/// Struct to check ASTs generated by ast.d
package struct ASTCheck{
	/// contains a list of currently available vars
	LinkedList!string definedVars;
	/// contains a list of vars already available
	const static string[] keyVars = [
		"args",
		"result"
	];
	/// contains types of nodes that return some data, like functionCall, stringLiteral...
	const static ASTNode.Type[] dataNodeTypes = [
		ASTNode.Type.FunctionCall,
		ASTNode.Type.NumberLiteral,
		ASTNode.Type.Operator,
		ASTNode.Type.StaticArray,
		ASTNode.Type.StringLiteral,
		ASTNode.Type.Variable
	];
	/// checks a script, and all subNodes, returns true if no error, otherwise, error is appended to misc.compileErrors
	bool checkScript(ASTNode script){
		bool r = true;
		// make sure all subNodes are functions, and check those functions
		foreach (node; script.subNodes){
			if (node.type != ASTNode.Type.Function){
				// error
				compileErrors.append(CompileError(node.lineno, "function definition expected"));
				r = false;
				// not a "fatal" error, so continue checking
			}else{
				// no error, but need to check inside the function
				r = checkFunction(node);
			}
		}
		return r;
	}

	/// identifies and checks an ASTNode
	private bool checkNode(ASTNode node){
		// TODO
		return false;
	}

	/// checks a function definition
	private bool checkFunction(ASTNode functionNode){
		// make sure it's a function
		if (functionNode.type == ASTNode.Type.Function){
			// ok
			// make sure there's only 1 subNode, and it's a block
			if (functionNode.subNodes.length != 1 || functionNode.subNodes[0].type != ASTNode.Type.Block){
				compileErrors.append(CompileError(functionNode.lineno, "invalid function definition"));
				return false;
			}else{
				// check it
				return checkBlock(functionNode.subNodes[0]);
			}
		}else{
			compileErrors.append(CompileError(functionNode.lineno, "function definition expected"));
			return false;
		}
	}

	/// checks a block
	private bool checkBlock(ASTNode block){
		// make sure it's a block
		if (block.type == ASTNode.Type.Block){
			foreach (statement; block.subNodes){
				if (statement.type == ASTNode.Type.FunctionCall){
					return checkFunctionCall(statement);
				}else if (statement.type == ASTNode.Type.Assign){
					return checkAssignment(statement);
				}else if (statement.type == ASTNode.Type.Block){
					return checkBlock(statement);
				}else if (statement.type == ASTNode.Type.IfStatement){
					// TODO add check if statement
				}else if (statement.type == ASTNode.Type.VarDeclare){
					// TODO add check varDeclare
				}else if (statement.type == ASTNode.Type.WhileStatement){
					// TODO add check while statement
				}else{
					// not a valid statement
					compileErrors.append(CompileError(statement.lineno, "not a valid statement"));
				}
			}
		}else{
			compileErrors.append(CompileError(block.lineno, "block expected"));
		}
	}

	/// checks a functionCall
	private bool checkFunctionCall(ASTNode fCall){
		// make sure it's a fCall
		if (fCall.type == ASTNode.Type.FunctionCall){
			// ok, make sure it has only 1 subNode, that is Args
			if (fCall.subNodes.length != 1 || fCall.subNodes[0].type != ASTNode.Type.Arguments){
				// error :(
				compileErrors.append(CompileError(fCall.lineno, "invalid function call"));
				return false;
			}else{
				// check the args
				bool r = true;
				foreach (arg; fCall.subNodes[0].subNodes){
					// make sure it's of correct type
					if (dataNodeTypes.hasElement(arg.type)){
						// type's ok, need to check the node
						r = checkNode(arg);
					}
				}
				return r;
			}

		}else{
			compileErrors.append(CompileError(fCall.lineno, "function call expected"));
			return false;
		}
	}

	/// checks an assignment statement
	private bool checkAssignment(ASTNode assign){
		// make sure it's an assignment
		if (assign.type == ASTNode.Type.Assign){
			// ok, check the if the var exists, and check the val, and there should be only s subNodes
			bool r = true;
			if (assign.subNodes.length != 2 || assign.subNodes[0].type != ASTNode.Type.Variable){
				compileErrors.append(CompileError(assign.lineno, "invalid assignment statement"));
				r = false;
				// not fatal, still need to check the val, but skip the var
			}else{
				// check the var
				r = /* TODO check var*/true;
			}
			// check the val
			if (dataNodeTypes.hasElement(assign.subNodes[1].type)){
				r = checkNode(assign.subNodes[1]);
			}else{
				compileErrors.append(CompileError(assign.lineno, "invalid assignment statement"));
				r = false;
			}
			return r;
		}else{
			compileErrors.append(CompileError(assign.lineno, "assignment statement expected"));
			return false;
		}
	}
}